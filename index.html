<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Just intonation pitch lattice (Primes up to 31)</title>
  <style>
    /* ------------------- BASE & LAYOUT ------------------- */
    body { 
        font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; 
        background: #f4f7f9; 
        color: #333; 
        position: relative; 
        margin: 0;
        padding-top: 80px; 
        padding-right: 300px; 
        overflow: hidden;
    }
    
    #header {
        position: fixed; 
        top: 0;
        left: 0;
        right: 300px; 
        background: #ffffff;
        padding: 10px 20px;
        border-bottom: 1px solid #ddd;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05); 
        z-index: 1000;
        box-sizing: border-box; 
    }

    #container { 
        height: calc(100vh - 80px);
        overflow: hidden;
        position: relative;
    }

    canvas {
        position: absolute;
        top: 0;
        left: 0;
        background: #fff;
    }
    
    /* FONT WEIGHT STYLES (BOLD) */
    h1 { font-size: 1.5em; margin: 0; font-weight: 700; }
    h2 { 
        font-size: 1.1em; 
        margin-top: 0; 
        margin-bottom: 8px; /* Reduced */
        color: #1e601e; 
        font-weight: 700; 
    }
    button { 
        font-weight: 700; 
        margin-top: 10px; /* Reduced */
    }

    /* FONT WEIGHT STYLES (LIGHT) */
    #header p { margin: 5px 0 0 0; font-size: 0.9em; color: #555; font-weight: 300; }
    .control-group p { font-weight: 300; font-size: 0.9em; margin: 5px 0 8px 0; }
    label { 
        display: block; 
        margin-top: 8px; /* Reduced */
        font-size: 0.9em; 
        font-weight: 300; 
        color: #444;
    }
    label span { font-weight: 300; }
    select, input[type="text"] { font-weight: 300; }
    
    .checkbox-group {
        display: flex;
        flex-wrap: wrap; 
        gap: 10px 15px; /* Reduced row gap */
    }
    .checkbox-group label { 
        display: flex;
        align-items: center;
        margin-top: 0;
        font-weight: 300; 
        cursor: pointer;
    }
    .checkbox-group input[type="radio"],
    .checkbox-group input[type="checkbox"] {
        margin-right: 5px;
    }

    /* ------------------- CONTROL PANEL STYLING ------------------- */
    #control-panel { 
        position: fixed; 
        top: 0;
        right: 0;
        width: 300px; 
        padding: 20px; 
        background: #ffffff;
        height: 100vh; 
        overflow-y: auto; 
        box-shadow: -2px 0 8px rgba(0,0,0,0.1); 
        z-index: 100;
        box-sizing: border-box;
    }

    .control-group { 
        margin-bottom: 15px; /* Reduced */
        padding-bottom: 15px; /* Reduced */
        border-bottom: 1px solid #eee;
    }
    .control-group:last-child { border-bottom: none; padding-bottom: 0; }
    
    input[type="range"] { 
        width: 100%; 
        margin: 5px 0; 
        -webkit-appearance: none; appearance: none;
        height: 4px; background: #ddd; border-radius: 2px;
    }
    
    .display-nodes-container {
        display: flex;
        gap: 20px;
    }
    .display-nodes-container > div:first-child { flex: 1.2; }
    .display-nodes-container > div:last-child { flex: 1; }
    
    #prime-filters-container .grid-label {
        margin-top: 0;
    }
    .prime-checkbox-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 4px 10px;
        margin-top: 5px;
    }
    .prime-checkbox-grid label {
        margin-top: 0;
        display: flex;
        align-items: center;
    }
    select#prime-limit-select, select#parent-limit-select {
        width: 100%;
        margin-top: 5px;
    }

  </style>
</head>
<body>
  
  <div id="header">
    <h1>Just intonation pitch lattice (Primes up to 31)</h1>
    <p>Click a node (or the octave selectors to the right of each node) to play pitches. All nodes default to within one octave above the fundamental. Use the control panel to control the sound, how pitches are displayed, which primes are displayed, and to locate specific intervals. Copyright Â© Alexander Garsden 2025.</p>
  </div>

  <div id="container">
    <canvas id="lattice"></canvas>
  </div>

  <div id="control-panel">
    
    <div class="control-group">
        <h2>Lattice View</h2>
        <label for="zoom-slider">Zoom Level: <span id="zoom-val">0.7</span>x</label>
        <input type="range" id="zoom-slider" min="0.1" max="2.0" step="0.05" value="0.7">
    </div>

    <div class="control-group">
        <h2>Sound Controls</h2>
        <label for="waveform">Waveform:</label>
        <select id="waveform">
            <option value="sine" selected>Sine</option>
            <option value="square">Square</option>
            <option value="triangle">Triangle</option>
            <option value="sawtooth">Sawtooth</option>
        </select>
        <label for="volume">Volume (Gain): <span id="volume-val">0.05</span></label>
        <input type="range" id="volume" min="0" max="0.5" step="0.01" value="0.05">
        <label for="attack">Attack: <span id="attack-val">0.50</span>s</label>
        <input type="range" id="attack" min="0.01" max="2.0" step="0.01" value="0.50">
        <label for="decay">Release: <span id="decay-val">1.00</span>s</label>
        <input type="range" id="decay" min="0.01" max="4.0" step="0.01" value="1.00">
        <label for="filter-freq">Low-Pass Cutoff (Hz): <span id="filter-freq-val">5000</span></label>
        <input type="range" id="filter-freq" min="100" max="20000" step="10" value="5000">
        <label for="filter-q">Resonance (Q): <span id="filter-q-val">1.0</span></label>
        <input type="range" id="filter-q" min="0.1" max="10" step="0.1" value="1.0">
        <button onclick="deactivateAll()">Stop All Sound</button>
    </div>
    
    <div class="control-group">
        <h2>Pitch Display & Fundamental</h2>
        <label>Pitch Display:</label>
        <div class="checkbox-group">
            <label><input type="radio" name="pitch-display" value="hz" id="display-hz" checked> Hz</label>
            <label><input type="radio" name="pitch-display" value="pitch" id="display-pitch"> Pitch Name (+ Cents)</label>
        </div>
        <label for="fundamental-input" id="fundamental-label">Fundamental (Hz):</label>
        <input type="text" id="fundamental-input" value="440" onchange="setFundamental()">
        <p>*Pitch example: A4 +0c</p>
    </div>

    <div class="control-group">
        <h2>Displayed Nodes</h2>
        <div class="display-nodes-container">
            <div>
                <label for="prime-limit-select" style="margin-top:0;">Prime Limit:</label>
                <select id="prime-limit-select">
                    <option value="custom">Custom</option>
                    <option value="3">3-limit</option>
                    <option value="5">5-limit</option>
                    <option value="7" selected>7-limit</option>
                    <option value="11">11-limit</option>
                    <option value="13">13-limit</option>
                    <option value="17">17-limit</option>
                    <option value="19">19-limit</option>
                    <option value="23">23-limit</option>
                    <option value="29">29-limit</option>
                    <option value="31">31-limit</option>
                </select>

                <label for="parent-limit-select">Generate primes >5 from:</label>
                <select id="parent-limit-select">
                    <option value="5-limit" selected>5-limit</option>
                    <option value="all">Primes >5</option>
                </select>
            </div>
            <div id="prime-filters-container">
                <label class="grid-label">Individual Primes:</label>
                <div id="prime-filters" class="prime-checkbox-grid">
                    <label><input type="checkbox" data-prime="3" checked> 3</label>
                    <label><input type="checkbox" data-prime="11"> 11</label>
                    <label><input type="checkbox" data-prime="5" checked> 5</label>
                    <label><input type="checkbox" data-prime="13"> 13</label>
                    <label><input type="checkbox" data-prime="7" checked> 7</label>
                    <label><input type="checkbox" data-prime="17"> 17</label>
                    <label><input type="checkbox" data-prime="19"> 19</label>
                    <label><input type="checkbox" data-prime="23"> 23</label>
                    <label><input type="checkbox" data-prime="29"> 29</label>
                    <label><input type="checkbox" data-prime="31"> 31</label>
                </div>
            </div>
        </div>
    </div>

    <div class="control-group">
        <h2>Locate Interval</h2>
        <p>Find all pairs of visible nodes matching a pitch class interval.</p>
        <div id="locate-interval-container" style="display: flex; align-items: center; gap: 5px; margin-top: 10px;">
            <input type="text" id="interval-num1" placeholder="e.g. 3" size="5" style="text-align: center; font-weight: 300;">
            <span style="font-weight: bold; color: #555;">:</span>
            <input type="text" id="interval-num2" placeholder="e.g. 2" size="5" style="text-align: center; font-weight: 300;">
            <button id="locate-interval-btn" style="margin-left: 10px; margin-top: 0;">Find</button>
            <button id="clear-interval-btn" style="margin-top: 0;">Clear</button>
        </div>
    </div>

  </div>

  <script>
    /* 1. GLOBAL STATE & AUDIO SETUP */
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();
    const masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.05; 
    const lowPassFilter = audioCtx.createBiquadFilter();
    lowPassFilter.type = 'lowpass';
    lowPassFilter.frequency.setValueAtTime(5000, audioCtx.currentTime); 
    lowPassFilter.Q.setValueAtTime(1.0, audioCtx.currentTime); 
    lowPassFilter.connect(masterGain);
    masterGain.connect(audioCtx.destination);
    
    let fundamental = 440;
    let waveform = 'sine';
    let attackTime = 0.5;
    let releaseTime = 1.0;
    const activePrimes = new Set([3, 5, 7]); 
    let displayMode = 'hz'; 
    let zoomLevel = 0.7;
    let pan = { x: 0, y: 0 };
    
    let hoveredNode = null;
    let hoveredOctave = { node: null, octaveIndex: -1 };
    let highlightedIntervals = [];

    /* 2. UTILITY FUNCTIONS */
    function gcd(a,b){ return b===0?a:gcd(b,a%b); }
    function simplifyFraction(n,d){ const g=gcd(Math.round(n),Math.round(d)); return [Math.round(n)/g,Math.round(d)/g]; }
    function normalizeOctave(n, d){ let num = Math.round(n); let den = Math.round(d); while(num / den >= 2) den *= 2; while(num / den < 1) num *= 2; return [num, den]; }
    function fractionLabel(n,d){ const [num,den]=simplifyFraction(n,d); return `${num}/${den}`; }
    function primeFactors(n){ const f=[]; let num=n; let d=2; while(num>1 && d<=num){ if(num%d===0){ f.push(d); num/=d; } else d++; } return f; }
    function ratioPrimeFactors([n,d]){ const nF=primeFactors(n); const dF=primeFactors(d); return [...new Set([...nF,...dF])].sort((a,b)=>a-b); }
    function getRatioPrimeFactorsWithMultiplicity([n, d]) { return [...primeFactors(n), ...primeFactors(d)].filter(p => p > 2); }
    const PITCH_NAMES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    const C4_FREQ = 440 * Math.pow(2, -9/12); 
    function freqToPitchName(freq) {
        if (freq <= 0) return "0 Hz"; const r=freq/C4_FREQ; const tS=12*Math.log2(r); const nS=Math.round(tS);
        const pI=(nS % 12 + 12)%12; const o=4+Math.floor(nS/12); const eF=C4_FREQ*Math.pow(2,nS/12);
        const c=1200*Math.log2(freq/eF); const pN=PITCH_NAMES[pI]+o; const cS=c.toFixed(0);
        return `${pN} ${cS>=0?'+':''}${cS}c`;
    }
    function pitchNameToFreq(pS) {
        const m=pS.match(/([A-G]#?)([0-9])\s*([+\-]\d+)c?/i); if(!m)return null; const[,n,oS,cS]=m;
        const o=parseInt(oS); const c=parseInt(cS); let pI=PITCH_NAMES.indexOf(n.toUpperCase()); if(pI===-1)return null;
        const tI=(o*12)+pI-48; const eF=C4_FREQ*Math.pow(2,tI/12); return eF*Math.pow(2,c/1200);
    }
    function shouldNodeBeVisible(node) {
        if (node.octaveStates.some(o => o !== null)) return true;
        const generationMode = document.getElementById('parent-limit-select').value;
        const non2PrimesWithMultiplicity = node.non2Primes_withMultiplicity;
        if (generationMode === '5-limit') {
            const highPrimesCount = non2PrimesWithMultiplicity.filter(p => p > 5).length;
            if (highPrimesCount > 1) return false; 
        }
        const uniqueNon2Primes = node.primes.filter(p => p > 2);
        if (fractionLabel(node.ratio[0], node.ratio[1]) === '1/1') return true; 
        return uniqueNon2Primes.every(p => activePrimes.has(p));
    }
    function getMaxPrime(node) { return node.primes.filter(p => p > 2).reduce((max, p) => Math.max(max, p), 1); }
    function getHighestPrimeLimit(node) {
        if (fractionLabel(node.ratio[0],node.ratio[1])==='1/1') return 1; const mP=node.primes.filter(p=>p>2).reduce((m,p)=>Math.max(m,p),3);
        if(mP>=31)return 31; if(mP>=29)return 29; if(mP>=23)return 23; if(mP>=19)return 19; if(mP>=17)return 17;
        if(mP>=13)return 13; if(mP>=11)return 11; if(mP>=7)return 7; if(mP>=5)return 5; return 3; 
    }
    function isFactorRelated(a,b,factor){
      const eps=1e-6; const r=(a.ratio[0]/a.ratio[1])/(b.ratio[0]/b.ratio[1]); 
      const k1=Math.round(Math.log2(factor/r)); if(Math.abs(r*Math.pow(2,k1)-factor)<eps) return true;
      const k2=Math.round(Math.log2((1/factor)/r)); if(Math.abs(r*Math.pow(2,k2)-(1/factor))<eps) return true;
      return false;
    }
    function normalizeIntervalRatio(n, d) {
        if (n === 0 || d === 0) return [0, 0];
        let num = Math.abs(n);
        let den = Math.abs(d);
        while (num > 0 && num % 2 === 0) num /= 2;
        while (den > 0 && den % 2 === 0) den /= 2;
        const commonDivisor = gcd(num, den);
        num /= commonDivisor;
        den /= commonDivisor;
        return num < den ? [num, den] : [den, num];
    }


    /* 3. LATTICE PARAMETERS & DATA */
    const latticeRange = { x: [-4, 4], y: [-2, 2] }; 
    const canvas = document.getElementById("lattice"); const ctx = canvas.getContext("2d");
    const WORLD_WIDTH = 4000; const WORLD_HEIGHT = 2600; 
    const spacing = 480; const centerX = WORLD_WIDTH / 2; const centerY = WORLD_HEIGHT / 2;
    const NODE_RADIUS = 20 * (2 / 3); const LABEL_Y_OFFSET = 25;
    const OCTAVE_MULTIPLIERS = [4, 2, 1, 0.5, 0.25];
    const OCTAVE_SELECTOR_X_OFFSET = 24; const OCTAVE_SELECTOR_Y_STEP = 10 * (2 / 3); const OCTAVE_SELECTOR_RADIUS = 2;
    
    const P_VECTORS = (() => {
        const rad = (deg) => deg * Math.PI / 180;
        const vectors = {
            7:  { r: 0.64, a: 20 }, 11: { r: 0.64, a: 70 },
            13: { r: 0.70, a: 40 }, 17: { r: 0.17, a: 50 },
            19: { r: 0.33, a: 30 }, 23: { r: 0.33, a: 60 },
            29: { r: 0.25, a: 10 }, 31: { r: 0.25, a: 80 }
        };
        
        const finalVectors = { 3: { x: 1, y: 0 }, 5: { x: 0, y: 1 } };
        for(const p in vectors) {
            const { r, a } = vectors[p];
            finalVectors[p] = { x: r * Math.cos(rad(a)), y: r * Math.sin(rad(a)) };
        }
        return finalVectors;
    })();

    /* 4. NODE GENERATION */
    let nodes;
    let existingRatios;

    function generateLatticeNodes(generationMode = 'all', nodesToPreserve = []) {
        const newNodes = []; const newRatios = new Map(); const ratioKey = r => r.join(',');
        nodesToPreserve.forEach(node => { const key = ratioKey(node.ratio); if (!newRatios.has(key)) { newNodes.push(node); newRatios.set(key, node); }});
        const createNode = (ratio, x, y) => {
            const key = ratioKey(ratio); if (newRatios.has(key)) return newRatios.get(key);
            const newNode = { ratio, x, y, primes: ratioPrimeFactors(ratio), non2Primes_withMultiplicity: getRatioPrimeFactorsWithMultiplicity(ratio), simplicityScore: ratio[0]*ratio[1], octaveStates: new Array(5).fill(null) };
            newNodes.push(newNode); newRatios.set(key, newNode); return newNode;
        };
        const baseGridSnapshot = [];
        for (let c3=latticeRange.x[0]; c3<=latticeRange.x[1]; c3++) {
            for (let c5=latticeRange.y[0]; c5<=latticeRange.y[1]; c5++) {
                const n3=c3>0?3**c3:1; const d3=c3<0?3**(-c3):1; const n5=c5>0?5**c5:1; const d5=c5<0?5**(-c5):1;
                const r=normalizeOctave(n3*n5,d3*d5);
                const x=centerX+(c3*P_VECTORS[3].x*spacing)+(c5*P_VECTORS[5].x*spacing);
                const y=centerY-((c3*P_VECTORS[3].y*spacing)+(c5*P_VECTORS[5].y*spacing));
                baseGridSnapshot.push(createNode(r,x,y));
            }
        }
        const expand = (base, prime) => {
            const v=P_VECTORS[prime]; const created=[];
            base.forEach(pN => {
                const uR=normalizeOctave(...simplifyFraction(pN.ratio[0]*prime,pN.ratio[1]));
                const uN=createNode(uR, pN.x+v.x*spacing, pN.y-v.y*spacing); if(uN)created.push(uN);
                const dR=normalizeOctave(...simplifyFraction(pN.ratio[0],pN.ratio[1]*prime));
                const dN=createNode(dR, pN.x-v.x*spacing, pN.y+v.y*spacing); if(dN)created.push(dN);
            });
            return created;
        };
        const hP=[7,11,13,17,19,23,29,31]; 
        if(generationMode==='5-limit'){hP.forEach(p=>{expand(baseGridSnapshot,p);});}
        else{ const fOS=[]; hP.forEach(p=>{fOS.push(...expand(baseGridSnapshot,p));}); hP.forEach(p=>{expand(fOS,p);}); }
        newNodes.sort((a,b)=>b.simplicityScore-a.simplicityScore);
        return {nodes:newNodes, existingRatios:newRatios};
    }

    /* 5. CANVAS DRAWING AND INTERACTION LOGIC */
    const NODE_COLORS = {
        1:{p:'#ccc',a:'#000'}, 3:{p:'#b3d6b3',a:'#1e601e'}, 5:{p:'#c3cde6',a:'#191970'},
        7:{p:'#e0b3e0',a:'#800080'}, 11:{p:'#ffb3b3',a:'#ff0000'}, 13:{p:'#e5c9b3',a:'#a0522d'},
        17:{p:'#b3e5e5',a:'#008080'}, 19:{p:'#a0d6b4', a: '#2E8B57' }, 23:{p:'#DAA520',a:'#b8860b'},
        29:{p:'#e5b3b3',a:'#b22222'}, 31:{p:'#b3cce5',a:'#0047ab'}
    };
    const LINE_COLORS = { dark: '#666', light: '#ddd' };
    
    function drawLattice() {
        requestAnimationFrame(() => {
            const dpr = window.devicePixelRatio || 1; const r = canvas.getBoundingClientRect();
            ctx.clearRect(0,0,r.width*dpr,r.height*dpr); ctx.save(); ctx.scale(dpr,dpr); 
            ctx.translate(r.width/2+pan.x, r.height/2+pan.y); ctx.scale(zoomLevel,zoomLevel); ctx.translate(-centerX,-centerY);
            const aP=[3,5,7,11,13,17,19,23,29,31]; const sMDS=spacing*1.2*spacing*1.2;
            let vN = nodes.filter(shouldNodeBeVisible);
            const pM = new Map();
            for(const n of [...vN].reverse()){const pK=`${n.x.toFixed(3)},${n.y.toFixed(3)}`;if(!pM.has(pK)){pM.set(pK,n);}}
            const nTR = Array.from(pM.values());
            for(let i=0;i<nTR.length;i++){
                for(let j=i+1;j<nTR.length;j++){
                    const f=nTR[i],g=nTR[j]; if(Math.pow(f.x-g.x,2)+Math.pow(f.y-g.y,2)>sMDS)continue;
                    for(const fac of aP){if(isFactorRelated(f,g,fac)){let c=LINE_COLORS.light;if(fac<=5&&getMaxPrime(f)<7&&getMaxPrime(g)<7){c=LINE_COLORS.dark;}
                    ctx.beginPath();ctx.strokeStyle=c;ctx.lineWidth=1;ctx.moveTo(f.x,f.y);ctx.lineTo(g.x,g.y);ctx.stroke();break;}}}}
            for(const n of nTR){
                const iAP=n.octaveStates.some(o=>o!==null); const l=getHighestPrimeLimit(n); const cS=NODE_COLORS[l];
                ctx.beginPath();ctx.arc(n.x,n.y,NODE_RADIUS,0,2*Math.PI);
                ctx.fillStyle=cS?(iAP?cS.a:cS.p):'#ff00ff'; ctx.fill();
                ctx.strokeStyle=iAP?'#000':'#333'; ctx.lineWidth=iAP?2:1; ctx.stroke();
                const fT=fractionLabel(n.ratio[0],n.ratio[1]); let fS=10; const aW=NODE_RADIUS*1.8;
                ctx.font=`${fS}px "Helvetica Neue"`; let tW=ctx.measureText(fT).width;
                while(tW>aW&&fS>4){fS--; ctx.font=`${fS}px "Helvetica Neue"`; tW=ctx.measureText(fT).width;}
                ctx.fillStyle='white'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(fT,n.x,n.y);
                
                OCTAVE_MULTIPLIERS.forEach((multiplier, idx) => {
                    const y = n.y - (2 * OCTAVE_SELECTOR_Y_STEP) + (idx * OCTAVE_SELECTOR_Y_STEP);
                    const x = n.x + OCTAVE_SELECTOR_X_OFFSET;
                    ctx.beginPath();
                    ctx.arc(x, y, OCTAVE_SELECTOR_RADIUS, 0, 2 * Math.PI);
                    ctx.fillStyle = n.octaveStates[idx] ? '#000' : '#b3b3b3';
                    ctx.strokeStyle = '#999';
                    ctx.lineWidth = 1;
                    ctx.fill();
                    ctx.stroke();

                    if (hoveredOctave.node === n && hoveredOctave.octaveIndex === idx) {
                        let hoverText = '';
                        if (displayMode === 'hz') {
                            const freq = fundamental * (n.ratio[0] / n.ratio[1]) * multiplier;
                            hoverText = `${freq.toFixed(1)} Hz`;
                        } else {
                            const labels = ['+2', '+1', '+0', '-1', '-2'];
                            hoverText = labels[idx];
                        }
                        ctx.fillStyle = '#555';
                        ctx.font = '8px "Helvetica Neue"';
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(hoverText, x + 5, y);
                    }
                });

                ctx.fillStyle = '#333';
                ctx.textAlign = 'center';
                ctx.font = '9px "Helvetica Neue"';
                let labelText;
                if (hoveredNode === n) {
                    if (fT === '1/1') {
                        labelText = 'Primes = 1';
                    } else {
                        const factors = [...new Set(n.non2Primes_withMultiplicity)].sort((a, b) => a - b);
                        labelText = 'Primes = ' + (factors.length > 0 ? factors.join(', ') : 'None');
                    }
                } else {
                    const baseFreq = fundamental * (n.ratio[0] / n.ratio[1]);
                    labelText = displayMode === 'hz' ? `${baseFreq.toFixed(1)}Hz` : freqToPitchName(baseFreq);
                }
                ctx.fillText(labelText, n.x, n.y + LABEL_Y_OFFSET);
            }

            if (highlightedIntervals.length > 0) {
                ctx.save();
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 3;
                ctx.globalAlpha = 0.85;
                highlightedIntervals.forEach(pair => {
                    const [nodeA, nodeB] = pair;
                    const ax = nodeA.x, ay = nodeA.y;
                    const bx = nodeB.x, by = nodeB.y;

                    const HIGHLIGHT_CIRCLE_RADIUS = NODE_RADIUS + 3;
                    const vecX = bx - ax;
                    const vecY = by - ay;
                    const dist = Math.sqrt(vecX * vecX + vecY * vecY);

                    if (dist === 0) return;

                    const unitX = vecX / dist;
                    const unitY = vecY / dist;

                    const startX = ax + unitX * HIGHLIGHT_CIRCLE_RADIUS;
                    const startY = ay + unitY * HIGHLIGHT_CIRCLE_RADIUS;
                    const endX = bx - unitX * HIGHLIGHT_CIRCLE_RADIUS;
                    const endY = by - unitY * HIGHLIGHT_CIRCLE_RADIUS;
                    
                    if (dist > 2 * HIGHLIGHT_CIRCLE_RADIUS) {
                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();
                    }

                    ctx.beginPath();
                    ctx.arc(ax, ay, HIGHLIGHT_CIRCLE_RADIUS, 0, 2 * Math.PI);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.arc(bx, by, HIGHLIGHT_CIRCLE_RADIUS, 0, 2 * Math.PI);
                    ctx.stroke();
                });
                ctx.restore(); 
            }

            ctx.restore();
        });
    }

    /* --- AUDIO & STATE LOGIC --- */
    function deactivateOctave(nD, oI) {
        if (nD && nD.octaveStates && nD.octaveStates[oI]) {
            const { source, env } = nD.octaveStates[oI];
            const now = audioCtx.currentTime;
            env.gain.cancelScheduledValues(now);
            env.gain.setValueAtTime(env.gain.value, now);
            env.gain.linearRampToValueAtTime(0, now + releaseTime);
            source.stop(now + releaseTime + 0.1);
            nD.octaveStates[oI] = null;
        }
    }
    
    function toggleOctave(nD,oI){
        if(!nD) return;
        const octaveIndex = (oI === undefined) ? 2 : oI;

        if(nD.octaveStates[octaveIndex] !== null) {
            deactivateAllOctaves(nD);
            return;
        }
        const now = audioCtx.currentTime;
        const baseFreq = fundamental * (nD.ratio[0] / nD.ratio[1]);
        const targetFreq = baseFreq * OCTAVE_MULTIPLIERS[octaveIndex];
        const env = audioCtx.createGain();
        env.connect(lowPassFilter);
        env.gain.setValueAtTime(0, now);
        env.gain.linearRampToValueAtTime(1, now + attackTime);
        const source = audioCtx.createOscillator();
        source.type = waveform;
        source.frequency.setValueAtTime(targetFreq, now);
        source.connect(env);
        source.start(now);
        nD.octaveStates[octaveIndex] = { source, env };
        drawLattice();
    }
    
    function deactivateAllOctaves(nD){if(!nD)return;let ch=false;nD.octaveStates.forEach((o,i)=>{if(o!==null){deactivateOctave(nD,i);ch=true;}});if(ch)drawLattice();}
    window.deactivateAll=function(){nodes.forEach(f=>deactivateAllOctaves(f));}

    /* --- EVENT HANDLERS --- */
    function resizeCanvas(){const c=document.getElementById('container');const dpr=window.devicePixelRatio||1;const r=c.getBoundingClientRect();canvas.width=r.width*dpr;canvas.height=r.height*dpr;canvas.style.width=`${r.width}px`;canvas.style.height=`${r.height}px`;drawLattice();}
    function getMouseWorldPos(e){const r=canvas.getBoundingClientRect();const mX=e.clientX-r.left;const mY=e.clientY-r.top;const wX=(mX-r.width/2-pan.x)/zoomLevel+centerX;const wY=(mY-r.height/2-pan.y)/zoomLevel+centerY;return{worldX:wX,worldY:wY};}
    
    canvas.addEventListener('mousemove', (e) => {
        const { worldX, worldY } = getMouseWorldPos(e);
        let newHoveredNode = null;
        let newHoveredOctave = { node: null, octaveIndex: -1 };
        let isHovering = false;
        
        const visibleNodes = nodes.filter(shouldNodeBeVisible);

        for (let i = visibleNodes.length - 1; i >= 0; i--) {
            const n = visibleNodes[i];
            
            for (let j = 0; j < OCTAVE_MULTIPLIERS.length; j++) {
                const sX = n.x + OCTAVE_SELECTOR_X_OFFSET;
                const sY = n.y - (2 * OCTAVE_SELECTOR_Y_STEP) + (j * OCTAVE_SELECTOR_Y_STEP);
                if (Math.pow(worldX - sX, 2) + Math.pow(worldY - sY, 2) < (OCTAVE_SELECTOR_RADIUS + 4) * (OCTAVE_SELECTOR_RADIUS + 4)) {
                    newHoveredOctave = { node: n, octaveIndex: j };
                    isHovering = true;
                    break;
                }
            }
            if (isHovering) break;

            if (Math.pow(worldX - n.x, 2) + Math.pow(worldY - n.y, 2) < NODE_RADIUS * NODE_RADIUS) {
                newHoveredNode = n;
                isHovering = true;
                break;
            }
        }

        canvas.style.cursor = isHovering ? 'pointer' : 'default';

        if (hoveredNode !== newHoveredNode || hoveredOctave.node !== newHoveredOctave.node || hoveredOctave.octaveIndex !== newHoveredOctave.octaveIndex) {
            hoveredNode = newHoveredNode;
            hoveredOctave = newHoveredOctave;
            drawLattice();
        }
    });

    canvas.addEventListener('click',(e)=>{const{worldX,worldY}=getMouseWorldPos(e);const vN=nodes.filter(shouldNodeBeVisible);const nTC=[...vN].reverse();
    for(const n of nTC){if(Math.pow(worldX-n.x,2)+Math.pow(worldY-n.y,2)<NODE_RADIUS*NODE_RADIUS){toggleOctave(n,2);return;}
    for(let j=0;j<OCTAVE_MULTIPLIERS.length;j++){const sX=n.x+OCTAVE_SELECTOR_X_OFFSET;const sY=n.y-(2*OCTAVE_SELECTOR_Y_STEP)+(j*OCTAVE_SELECTOR_Y_STEP);if(Math.pow(worldX-sX,2)+Math.pow(worldY-sY,2)<(OCTAVE_SELECTOR_RADIUS+4)*(OCTAVE_SELECTOR_RADIUS+4)){toggleOctave(n,j);return;}}}});
    canvas.addEventListener('wheel',(e)=>{e.preventDefault();pan.x-=e.deltaX;pan.y-=e.deltaY;drawLattice();});
    
    document.getElementById('zoom-slider').addEventListener('input',(e)=>{zoomLevel=parseFloat(e.target.value);document.getElementById('zoom-val').textContent=zoomLevel.toFixed(2);drawLattice();});
    document.getElementById('waveform').addEventListener('change',(e)=>{waveform=e.target.value;});
    document.getElementById('attack').addEventListener('input',(e)=>{attackTime=parseFloat(e.target.value);document.getElementById('attack-val').textContent=attackTime.toFixed(2);});
    document.getElementById('decay').addEventListener('input',(e)=>{releaseTime=parseFloat(e.target.value);document.getElementById('decay-val').textContent=releaseTime.toFixed(2);});
    document.getElementById('volume').addEventListener('input',(e)=>{const v=parseFloat(e.target.value);masterGain.gain.setValueAtTime(v,audioCtx.currentTime);document.getElementById('volume-val').textContent=v.toFixed(2);});
    document.getElementById('filter-freq').addEventListener('input',(e)=>{const v=parseFloat(e.target.value);lowPassFilter.frequency.setValueAtTime(v,audioCtx.currentTime);document.getElementById('filter-freq-val').textContent=v.toFixed(0);});
    document.getElementById('filter-q').addEventListener('input',(e)=>{const v=parseFloat(e.target.value);lowPassFilter.Q.setValueAtTime(v,audioCtx.currentTime);document.getElementById('filter-q-val').textContent=v.toFixed(1);});
    window.setFundamental=function(){const i=document.getElementById('fundamental-input').value.trim();let nF=0;if(displayMode==='hz')nF=parseFloat(i);else nF=pitchNameToFreq(i);
    if(nF>0){fundamental=nF;if(displayMode==='pitch')document.getElementById('fundamental-input').value=freqToPitchName(fundamental);else document.getElementById('fundamental-input').value=fundamental.toFixed(2);deactivateAll();drawLattice();}
    else{alert(`Invalid format for ${displayMode==='hz'?'Frequency (Hz)':'Pitch Name (+ Cents)'}. Example: 440 or A4 +0c.`);if(displayMode==='hz')document.getElementById('fundamental-input').value=fundamental.toFixed(2);else document.getElementById('fundamental-input').value=freqToPitchName(fundamental);}};
    document.querySelectorAll('input[name="pitch-display"]').forEach(r=>{r.addEventListener('change',(e)=>{displayMode=e.target.value;const iE=document.getElementById('fundamental-input');const lE=document.getElementById('fundamental-label');
    if(displayMode==='hz'){lE.textContent='Fundamental (Hz):';iE.value=fundamental.toFixed(2);}else{lE.textContent='Fundamental (Pitch + Cents):';iE.value=freqToPitchName(fundamental);}drawLattice();});});
    
    const pLS=document.getElementById('prime-limit-select');const pCB=document.querySelectorAll('#prime-filters input[type="checkbox"]');
    const pL={'3':[3],'5':[3,5],'7':[3,5,7],'11':[3,5,7,11],'13':[3,5,7,11,13],'17':[3,5,7,11,13,17],'19':[3,5,7,11,13,17,19],'23':[3,5,7,11,13,17,19,23],'29':[3,5,7,11,13,17,19,23,29],'31':[3,5,7,11,13,17,19,23,29,31]};
    function updateFiltersFromDropdown(){const l=pLS.value;if(l==='custom')return;const pTS=new Set(pL[l]);activePrimes.clear();pCB.forEach(cb=>{const p=parseInt(cb.dataset.prime);cb.checked=pTS.has(p);if(cb.checked)activePrimes.add(p);});drawLattice();}
    pLS.addEventListener('change',updateFiltersFromDropdown);
    pCB.forEach(cb=>{cb.addEventListener('change',(e)=>{const p=parseInt(e.target.dataset.prime);if(e.target.checked){activePrimes.add(p);}else{activePrimes.delete(p);}pLS.value='custom';drawLattice();});});

    document.getElementById('parent-limit-select').addEventListener('change', (e) => {
        const newMode = e.target.value;
        const activeNodesToPreserve = nodes.filter(n => n.octaveStates.some(osc => osc !== null));
        const newData = generateLatticeNodes(newMode, activeNodesToPreserve);
        nodes = newData.nodes;
        existingRatios = newData.existingRatios;
        drawLattice();
    });

    document.getElementById('locate-interval-btn').addEventListener('click', () => {
        const num1 = parseInt(document.getElementById('interval-num1').value);
        const num2 = parseInt(document.getElementById('interval-num2').value);

        if (isNaN(num1) || isNaN(num2) || num1 <= 0 || num2 <= 0) {
            alert('Please enter valid positive integers for the ratio.');
            highlightedIntervals = [];
            drawLattice();
            return;
        }

        const targetInterval = normalizeIntervalRatio(num1, num2);
        highlightedIntervals = [];
        const visibleNodes = nodes.filter(shouldNodeBeVisible);

        for (let i = 0; i < visibleNodes.length; i++) {
            for (let j = i + 1; j < visibleNodes.length; j++) {
                const nodeA = visibleNodes[i];
                const nodeB = visibleNodes[j];

                const intervalNum = nodeA.ratio[0] * nodeB.ratio[1];
                const intervalDen = nodeA.ratio[1] * nodeB.ratio[0];
                const nodeInterval = normalizeIntervalRatio(intervalNum, intervalDen);

                if (nodeInterval[0] === targetInterval[0] && nodeInterval[1] === targetInterval[1]) {
                    highlightedIntervals.push([nodeA, nodeB]);
                }
            }
        }
        drawLattice();
    });

    document.getElementById('clear-interval-btn').addEventListener('click', () => {
        highlightedIntervals = [];
        document.getElementById('interval-num1').value = '';
        document.getElementById('interval-num2').value = '';
        drawLattice();
    });

    // Initial setup calls
    window.addEventListener('resize', resizeCanvas); 
    const initialData = generateLatticeNodes(document.getElementById('parent-limit-select').value);
    nodes = initialData.nodes;
    existingRatios = initialData.existingRatios;
    resizeCanvas();

  </script>
</body>
</html>
